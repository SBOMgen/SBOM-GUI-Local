import { extname } from 'path';
import { getFlags } from './feature_flags.js';
import { getFunctionFromPath, getFunctionsFromPaths } from './runtimes/index.js';
import { findISCDeclarationsInPath } from './runtimes/node/in_source_config/index.js';
import { RUNTIME } from './runtimes/runtime.js';
import { RuntimeCache } from './utils/cache.js';
import { listFunctionsDirectories, resolveFunctionsDirectories } from './utils/fs.js';
import { getLogger } from './utils/logger.js';
export { zipFunction, zipFunctions } from './zip.js';
export { ARCHIVE_FORMAT } from './archive.js';
export { NODE_BUNDLER } from './runtimes/node/bundlers/types.js';
export { RUNTIME } from './runtimes/runtime.js';
export { MODULE_FORMAT } from './runtimes/node/utils/module_format.js';
const augmentWithISC = async (func, featureFlags) => {
    // ISC is currently only supported in JavaScript and TypeScript functions
    // and only supports scheduled functions.
    if (func.runtime.name !== RUNTIME.JAVASCRIPT) {
        return func;
    }
    const inSourceConfig = await findISCDeclarationsInPath(func.mainFile, {
        functionName: func.name,
        featureFlags,
        logger: getLogger(),
    });
    return { ...func, inSourceConfig };
};
// List all Netlify Functions main entry files for a specific directory
export const listFunctions = async function (relativeSrcFolders, { featureFlags: inputFeatureFlags, config, configFileDirectories, parseISC = false, } = {}) {
    const featureFlags = getFlags(inputFeatureFlags);
    const srcFolders = resolveFunctionsDirectories(relativeSrcFolders);
    const paths = await listFunctionsDirectories(srcFolders);
    const cache = new RuntimeCache();
    const functionsMap = await getFunctionsFromPaths(paths, { cache, config, configFileDirectories, featureFlags });
    const functions = [...functionsMap.values()];
    const augmentedFunctions = parseISC
        ? await Promise.all(functions.map((func) => augmentWithISC(func, featureFlags)))
        : functions;
    return augmentedFunctions.map(getListedFunction);
};
// Finds a function at a specific path.
export const listFunction = async function (path, { featureFlags: inputFeatureFlags, config, configFileDirectories, parseISC = false, } = {}) {
    const featureFlags = getFlags(inputFeatureFlags);
    const cache = new RuntimeCache();
    const func = await getFunctionFromPath(path, { cache, config, configFileDirectories, featureFlags });
    if (!func) {
        return;
    }
    const augmentedFunction = parseISC ? await augmentWithISC(func, featureFlags) : func;
    return getListedFunction(augmentedFunction);
};
// List all Netlify Functions files for a specific directory
export const listFunctionsFiles = async function (relativeSrcFolders, { basePath, config, configFileDirectories, featureFlags: inputFeatureFlags, parseISC = false, } = {}) {
    const featureFlags = getFlags(inputFeatureFlags);
    const srcFolders = resolveFunctionsDirectories(relativeSrcFolders);
    const paths = await listFunctionsDirectories(srcFolders);
    const cache = new RuntimeCache();
    const functionsMap = await getFunctionsFromPaths(paths, { cache, config, configFileDirectories, featureFlags });
    const functions = [...functionsMap.values()];
    const augmentedFunctions = parseISC
        ? await Promise.all(functions.map((func) => augmentWithISC(func, featureFlags)))
        : functions;
    const listedFunctionsFiles = await Promise.all(augmentedFunctions.map((func) => getListedFunctionFiles(func, { basePath, featureFlags })));
    return listedFunctionsFiles.flat();
};
const getListedFunction = function ({ config, extension, inSourceConfig, mainFile, name, runtime, }) {
    return {
        displayName: config.name,
        extension,
        generator: config.generator,
        mainFile,
        name,
        runtime: runtime.name,
        runtimeAPIVersion: inSourceConfig ? inSourceConfig?.runtimeAPIVersion ?? 1 : undefined,
        schedule: inSourceConfig?.schedule ?? config.schedule,
    };
};
const getListedFunctionFiles = async function (func, options) {
    const srcFiles = await getSrcFiles({
        ...func,
        ...options,
        runtimeAPIVersion: func.inSourceConfig?.runtimeAPIVersion ?? 1,
    });
    return srcFiles.map((srcFile) => ({ ...getListedFunction(func), srcFile, extension: extname(srcFile) }));
};
const getSrcFiles = async function ({ extension, runtime, srcPath, ...args }) {
    const { getSrcFiles: getRuntimeSrcFiles } = runtime;
    if (extension === '.zip' || typeof getRuntimeSrcFiles !== 'function') {
        return [srcPath];
    }
    return await getRuntimeSrcFiles({
        extension,
        runtime,
        srcPath,
        ...args,
    });
};
//# sourceMappingURL=main.js.map